{"version":3,"file":"index.js","sources":["../src/rules.ts","../src/helpers.ts","../src/Tokenizer.ts"],"sourcesContent":["const noopTest = { exec: () => null } as unknown as RegExp;\n\nfunction edit(regex: string | RegExp, opt = '') {\n  let source = typeof regex === 'string' ? regex : regex.source;\n  const obj = {\n    replace: (name: string | RegExp, val: string | RegExp) => {\n      let valSource = typeof val === 'string' ? val : val.source;\n      valSource = valSource.replace(other.caret, '$1');\n      source = source.replace(name, valSource);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(source, opt);\n    },\n  };\n  return obj;\n}\n\nexport const other = {\n  codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n  outputLinkReplace: /\\\\([\\[\\]])/g,\n  indentCodeCompensation: /^(\\s+)(?:```)/,\n  beginningSpace: /^\\s+/,\n  endingHash: /#$/,\n  startingSpaceChar: /^ /,\n  endingSpaceChar: / $/,\n  nonSpaceChar: /[^ ]/,\n  newLineCharGlobal: /\\n/g,\n  tabCharGlobal: /\\t/g,\n  multipleSpaceGlobal: /\\s+/g,\n  blankLine: /^[ \\t]*$/,\n  doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n  blockquoteStart: /^ {0,3}>/,\n  blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n  blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n  listReplaceTabs: /^\\t+/,\n  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n  listIsTask: /^\\[[ xX]\\] /,\n  listReplaceTask: /^\\[[ xX]\\] +/,\n  anyLine: /\\n.*\\n/,\n  hrefBrackets: /^<(.*)>$/,\n  tableDelimiter: /[:|]/,\n  tableAlignChars: /^\\||\\| *$/g,\n  tableRowBlankLine: /\\n[ \\t]*$/,\n  tableAlignRight: /^ *-+: *$/,\n  tableAlignCenter: /^ *:-+: *$/,\n  tableAlignLeft: /^ *:-+ *$/,\n  startATag: /^<a /i,\n  endATag: /^<\\/a>/i,\n  startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n  endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n  startAngleBracket: /^</,\n  endAngleBracket: />$/,\n  pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n  unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n  escapeTest: /[&<>\"']/,\n  escapeReplace: /[&<>\"']/g,\n  escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n  escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n  unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n  caret: /(^|[^\\[])\\^/g,\n  percentDecode: /%25/g,\n  findPipe: /\\|/g,\n  splitPipe: / \\|/,\n  slashPipe: /\\\\\\|/g,\n  carriageReturn: /\\r\\n|\\r/g,\n  spaceLine: /^ +$/gm,\n  notSpaceStart: /^\\S*/,\n  endingNewline: /\\n$/,\n  listItemRegex: (bull: string) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n  nextBulletRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n  hrRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n  fencesBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n  headingBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n  htmlBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n\n/**\n * Block-Level Grammar\n */\n\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/\\|table/g, '') // table not in commonmark\n  .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n  .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n  .replace('label', _blockLabel)\n  .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n  .getRegex();\n\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n  .replace(/bull/g, bullet)\n  .getRegex();\n\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n  + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\n  '^ {0,3}(?:' // optional indentation\n+ '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n+ '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n+ '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n+ '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n+ '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n+ '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n+ '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n+ '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n+ ')', 'i')\n  .replace('comment', _comment)\n  .replace('tag', _tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst paragraph = edit(_paragraph)\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n  .replace('paragraph', paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nconst blockNormal = {\n  blockquote,\n  code: blockCode,\n  def,\n  fences,\n  heading,\n  hr,\n  html,\n  lheading,\n  list,\n  newline,\n  paragraph,\n  table: noopTest,\n  text: blockText,\n};\n\ntype BlockKeys = keyof typeof blockNormal;\n\n/**\n * GFM Block Grammar\n */\n\nconst gfmTable = edit(\n  '^ *([^\\\\n ].*)\\\\n' // Header\n+ ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n+ '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockGfm: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  lheading: lheadingGfm,\n  table: gfmTable,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('table', gfmTable) // interrupt paragraphs with table\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex(),\n};\n\n/**\n * Inline-Level Grammar\n */\n\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n  .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\n\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\n\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\nconst emStrongRDelimAstCore =\n  '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n+ '|[^*]+(?=[^*])' // Consume to delim\n+ '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n+ '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n+ '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n+ '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\n\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n  .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\n  '^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n+ '|[^_]+(?=[^_])' // Consume to delim\n+ '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n+ '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n+ '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n+ '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n+ '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n  .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n  .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n  .getRegex();\n\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit(\n  '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n  .replace('comment', _inlineComment)\n  .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n  .replace('label', _inlineLabel)\n  .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n  .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n  .getRegex();\n\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n  .replace('label', _inlineLabel)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n  .replace('reflink', reflink)\n  .replace('nolink', nolink)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\nconst inlineNormal = {\n  _backpedal: noopTest, // only used for GFM url\n  anyPunctuation,\n  autolink,\n  blockSkip,\n  br,\n  code: inlineCode,\n  del: noopTest,\n  emStrongLDelim,\n  emStrongRDelimAst,\n  emStrongRDelimUnd,\n  escape,\n  link,\n  nolink,\n  punctuation,\n  reflink,\n  reflinkSearch,\n  tag,\n  text: inlineText,\n  url: noopTest,\n};\n\ntype InlineKeys = keyof typeof inlineNormal;\n\n\n/**\n * GFM Inline Grammar\n */\n\nconst inlineGfm: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  emStrongRDelimAst: emStrongRDelimAstGfm,\n  emStrongLDelim: emStrongLDelimGfm,\n  url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n    .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n    .getRegex(),\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n  text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\nconst inlineBreaks: Record<InlineKeys, RegExp> = {\n  ...inlineGfm,\n  br: edit(br).replace('{2,}', '*').getRegex(),\n  text: edit(inlineGfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex(),\n};\n\n/**\n * exports\n */\n\nexport const block = {\n  normal: blockNormal,\n  gfm: blockGfm,\n};\n\nexport const inline = {\n  normal: inlineNormal,\n  gfm: inlineGfm,\n  breaks: inlineBreaks,\n};\n\nexport interface Rules {\n  other: typeof other\n  block: Record<BlockKeys, RegExp>\n  inline: Record<InlineKeys, RegExp>\n}\n","import { other } from './rules.ts';\n\n\n\nexport function splitCells(tableRow: string, count?: number) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n      let escaped = false;\n      let curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(other.splitPipe);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) {\n    cells.shift();\n  }\n  if (cells.length > 0 && !cells.at(-1)?.trim()) {\n    cells.pop();\n  }\n\n  if (count) {\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) cells.push('');\n    }\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str: string, c: string, invert?: boolean) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nexport function findClosingBracket(str: string, b: string) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n\n  let level = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  return -1;\n}\n","import {\n  rtrim,\n  splitCells,\n  findClosingBracket,\n} from './helpers';\nimport { block, inline, other, type Rules } from './rules';\nimport type { Links, Tokens, Token, TokensList } from './Tokens';\n\nfunction outputLink(cap: string[], link: Pick<Tokens.Link, 'href' | 'title'>, raw: string, lexer: Lexer, rules: Rules): Tokens.Link | Tokens.Image {\n  const href = link.href;\n  const title = link.title || null;\n  const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n\n  if (cap[0].charAt(0) !== '!') {\n    lexer.state.inLink = true;\n    const token: Tokens.Link = {\n      type: 'link',\n      raw,\n      href,\n      title,\n      text,\n      tokens: lexer.inlineTokens(text),\n    };\n    lexer.state.inLink = false;\n    return token;\n  }\n  return {\n    type: 'image',\n    raw,\n    href,\n    title,\n    text,\n  };\n}\n\nfunction indentCodeCompensation(raw: string, text: string, rules: Rules) {\n  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n  if (matchIndentToCode == null) return text;\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(rules.other.beginningSpace);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n\n\ntype ExtensionIndexer = (this: { lexer: Lexer }, src: string) => number\ntype ExtensionTokenizer = (this: { lexer: Lexer }, src: string, tokens: Token[]) => Token\n\n\ninterface LexerOptions {\n  extensions?: {\n    startBlock?: ExtensionIndexer[]\n\n    inline?: ExtensionTokenizer[]\n    startInline?: ExtensionIndexer[]\n  };\n  gfm?: boolean\n  gfmLineBreaks?: boolean\n}\n\n/** \n * Fully compatible `Lexer` forked from [Marked](https://github.com/markedjs/marked).\n * \n * The only change made is removing code that is not a part of `Lexer` to reduce the size.\n */\nexport class Lexer {\n  rules: Rules;\n  tokens: TokensList;\n  state = {\n    inLink: false,\n    inRawBlock: false,\n    top: true,\n  }\n\n\n  constructor(public options: LexerOptions = {}) {\n    // TokenList cannot be created in one go\n    this.tokens = [] as never;\n    this.tokens.links = {}\n\n    this.rules = {\n      other,\n      block: block.normal,\n      inline: inline.normal,\n    }\n\n    if (this.options.gfm) {\n      this.rules.block = block.gfm;\n      this.rules.inline = inline.gfm;\n\n      if (this.options.gfmLineBreaks) {\n        this.rules.inline = inline.breaks;\n      }\n    }\n  }\n\n\n  private inlineQueue: { src: string, tokens: Token[] }[] = []\n\n  lex(src: string) {\n    src = src.replace(other.carriageReturn, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    for (let i = 0; i < this.inlineQueue.length; i++) {\n      const next = this.inlineQueue[i];\n      this.inlineTokens(next.src, next.tokens);\n    }\n    this.inlineQueue = [];\n\n    return this.tokens;\n  }\n\n\n  /**\n   * Lexing\n   */\n  blockTokens(src: string, tokens?: Token[], lastParagraphClipped?: boolean): Token[];\n  blockTokens(src: string, tokens?: TokensList, lastParagraphClipped?: boolean): TokensList;\n  blockTokens(src: string, tokens: Token[] = [], lastParagraphClipped = false) {\n    while (src) {\n      let token: Tokens.Generic | undefined;\n\n      // newline\n      if (token = this.space(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.raw.length === 1 && lastToken !== undefined) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unnecessary paragraph tags\n          lastToken.raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.code(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.def(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title,\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.paragraph(cutSrc))) {\n        const lastToken = tokens.at(-1);\n        if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = cutSrc.length !== src.length;\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.text(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src: string, tokens: Token[] = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src: string, tokens: Token[] = []): Token[] {\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match: RegExpExecArray | null = null;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index)\n              + '[' + 'a'.repeat(match[0].length - 2) + ']'\n              + maskedSrc.slice(this.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n    // Mask out other blocks\n    while ((match = this.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out escaped characters\n    while ((match = this.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.rules.inline.anyPunctuation.lastIndex);\n    }\n\n    let keepPrevChar = false;\n    let prevChar = '';\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      let token: Tokens.Generic | undefined;\n\n      // extensions\n      if (this.options.extensions?.inline?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tag(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // link\n      if (token = this.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.type === 'text' && lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.autolink(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.url(src))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.inlineText(cutSrc)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    return tokens;\n  }\n\n\n  // --- Lexicon --- //\n\n  space(src: string): Tokens.Space | undefined {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0],\n      };\n    }\n  }\n\n  code(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: rtrim(text, '\\n')\n      };\n    }\n  }\n\n  fences(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n        text,\n      };\n    }\n  }\n\n  heading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (this.rules.other.endingHash.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.inline(text),\n      };\n    }\n  }\n\n  hr(src: string): Tokens.Hr | undefined {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: rtrim(cap[0], '\\n'),\n      };\n    }\n  }\n\n  blockquote(src: string): Tokens.Blockquote | undefined {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      let lines = rtrim(cap[0], '\\n').split('\\n');\n      let raw = '';\n      let text = '';\n      const tokens: Token[] = [];\n\n      while (lines.length > 0) {\n        let inBlockquote = false;\n        const currentLines = [];\n\n        let i;\n        for (i = 0; i < lines.length; i++) {\n          // get lines up to a continuation\n          if (this.rules.other.blockquoteStart.test(lines[i])) {\n            currentLines.push(lines[i]);\n            inBlockquote = true;\n          } else if (!inBlockquote) {\n            currentLines.push(lines[i]);\n          } else {\n            break;\n          }\n        }\n        lines = lines.slice(i);\n\n        const currentRaw = currentLines.join('\\n');\n        const currentText = currentRaw\n          // precede setext continuation with 4 spaces so it isn't a setext\n          .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n          .replace(this.rules.other.blockquoteSetextReplace2, '');\n        raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n        text = text ? `${text}\\n${currentText}` : currentText;\n\n        // parse blockquote lines as top level tokens\n        // merge paragraphs if this is a continuation\n        const top = this.state.top;\n        this.state.top = true;\n        this.blockTokens(currentText, tokens, true);\n        this.state.top = top;\n\n        // if there is no continuation then we are done\n        if (lines.length === 0) {\n          break;\n        }\n\n        const lastToken = tokens.at(-1);\n\n        if (lastToken?.type === 'code') {\n          // blockquote continuation cannot be preceded by a code block\n          break;\n        } else if (lastToken?.type === 'blockquote') {\n          // include continuation in nested blockquote\n          const oldToken = lastToken as Tokens.Blockquote;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.blockquote(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n          break;\n        } else if (lastToken?.type === 'list') {\n          // include continuation in nested list\n          const oldToken = lastToken as Tokens.List;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.list(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n          lines = newText.substring(tokens.at(-1)!.raw.length).split('\\n');\n          continue;\n        }\n      }\n\n      return {\n        type: 'blockquote',\n        raw,\n        tokens,\n        text,\n      };\n    }\n  }\n\n  list(src: string): Tokens.List | undefined {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list: Tokens.List = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: [],\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      // Get next list item\n      const itemRegex = this.rules.other.listItemRegex(bull);\n      let endsWithBlankLine = false;\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        let endEarly = false;\n        let raw = '';\n        let itemContents = '';\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t: string) => ' '.repeat(3 * t.length));\n        let nextLine = src.split('\\n', 1)[0];\n        let blankLine = !line.trim();\n\n        let indent = 0;\n        if (blankLine) {\n          indent = cap[1].length + 1;\n        } else {\n          indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n          const hrRegex = this.rules.other.hrRegex(indent);\n          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            const rawLine = src.split('\\n', 1)[0];\n            let nextLineWithoutTabs;\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of html block\n            if (htmlBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(nextLine)) {\n              break;\n            }\n\n            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLineWithoutTabs.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (this.rules.other.doubleBlankLine.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        let istask: RegExpExecArray | null = null;\n        let ischecked: boolean | undefined;\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = this.rules.other.listIsTask.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents,\n          tokens: [],\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      const lastItem = list.items.at(-1);\n      if (lastItem) {\n        lastItem.raw = lastItem.raw.trimEnd();\n        lastItem.text = lastItem.text.trimEnd();\n      } else {\n        // not a list since there were no items\n        return;\n      }\n      list.raw = list.raw.trimEnd();\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (let i = 0; i < list.items.length; i++) {\n        this.state.top = false;\n        list.items[i].tokens = this.blockTokens(list.items[i].text, []);\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (let i = 0; i < list.items.length; i++) {\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src: string): Tokens.HTML | undefined {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token: Tokens.HTML = {\n        type: 'html',\n        block: true,\n        raw: cap[0],\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0],\n      };\n      return token;\n    }\n  }\n\n  def(src: string): Tokens.Def | undefined {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title,\n      };\n    }\n  }\n\n  table(src: string): Tokens.Table | undefined {\n    const cap = this.rules.block.table.exec(src);\n    if (!cap) {\n      return;\n    }\n\n    if (!this.rules.other.tableDelimiter.test(cap[2])) {\n      // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n      return;\n    }\n\n    const headers = splitCells(cap[1]);\n    const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n    const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n\n    const item: Tokens.Table = {\n      type: 'table',\n      raw: cap[0],\n      header: [],\n      align: [],\n      rows: [],\n    };\n\n    if (headers.length !== aligns.length) {\n      // header and align columns must be equal, rows can be different.\n      return;\n    }\n\n    for (const align of aligns) {\n      if (this.rules.other.tableAlignRight.test(align)) {\n        item.align.push('right');\n      } else if (this.rules.other.tableAlignCenter.test(align)) {\n        item.align.push('center');\n      } else if (this.rules.other.tableAlignLeft.test(align)) {\n        item.align.push('left');\n      } else {\n        item.align.push(null);\n      }\n    }\n\n    for (let i = 0; i < headers.length; i++) {\n      item.header.push({\n        text: headers[i],\n        tokens: this.inline(headers[i]),\n        header: true,\n        align: item.align[i],\n      });\n    }\n\n    for (const row of rows) {\n      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n        return {\n          text: cell,\n          tokens: this.inline(cell),\n          header: false,\n          align: item.align[i],\n        };\n      }));\n    }\n\n    return item;\n  }\n\n  lheading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.inline(cap[1]),\n      };\n    }\n  }\n\n  paragraph(src: string): Tokens.Paragraph | undefined {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.inline(text),\n      };\n    }\n  }\n\n  text(src: string): Tokens.Text | undefined {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.inline(cap[0]),\n      };\n    }\n  }\n\n  escape(src: string): Tokens.Escape | undefined {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: cap[1],\n      };\n    }\n  }\n\n  tag(src: string): Tokens.Tag | undefined {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.state.inLink && this.rules.other.startATag.test(cap[0])) {\n        this.state.inLink = true;\n      } else if (this.state.inLink && this.rules.other.endATag.test(cap[0])) {\n        this.state.inLink = false;\n      }\n      if (!this.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n        this.state.inRawBlock = true;\n      } else if (this.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n        this.state.inRawBlock = false;\n      }\n\n      return {\n        type: 'html',\n        raw: cap[0],\n        inLink: this.state.inLink,\n        inRawBlock: this.state.inRawBlock,\n        block: false,\n        text: cap[0],\n      };\n    }\n  }\n\n  link(src: string): Tokens.Link | Tokens.Image | undefined {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap == null) return\n\n    const trimmedUrl = cap[2].trim();\n    if (this.rules.other.startAngleBracket.test(trimmedUrl)) {\n      // commonmark requires matching angle brackets\n      if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n        return;\n      }\n\n      // ending angle bracket cannot be escaped\n      const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n      if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n        return;\n      }\n    } else {\n      // find closing parenthesis\n      const lastParenIndex = findClosingBracket(cap[2], '()');\n      if (lastParenIndex > -1) {\n        const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n        const linkLen = start + cap[1].length + lastParenIndex;\n        cap[2] = cap[2].substring(0, lastParenIndex);\n        cap[0] = cap[0].substring(0, linkLen).trim();\n        cap[3] = '';\n      }\n    }\n\n    let href = cap[2];\n    let title = '';\n    title = cap[3] ? cap[3].slice(1, -1) : '';\n\n\n    href = href.trim();\n    if (this.rules.other.startAngleBracket.test(href)) {\n      href = href.slice(1, -1);\n    }\n    return outputLink(cap, {\n      href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n      title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n    }, cap[0], this, this.rules);\n  }\n\n  reflink(src: string, links: Links): Tokens.Link | Tokens.Image | Tokens.Text | undefined {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n      || (cap = this.rules.inline.nolink.exec(src))) {\n      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const link = links[linkString.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text,\n        };\n      }\n      return outputLink(cap, link, cap[0], this, this.rules);\n    }\n  }\n\n  emStrong(src: string, maskedSrc: string, prevChar = ''): Tokens.Em | Tokens.Strong | undefined {\n    let match = this.rules.inline.emStrongLDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n      // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n      const lLength = [...match[0]].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = [...rDelim].length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n        // char length can be >1 for unicode characters;\n        const lastCharLength = [...match[0]][0].length;\n        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.inlineTokens(text),\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.inlineTokens(text),\n        };\n      }\n    }\n  }\n\n  codespan(src: string): Tokens.Codespan | undefined {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text,\n      };\n    }\n  }\n\n  br(src: string): Tokens.Br | undefined {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0],\n      };\n    }\n  }\n\n  del(src: string): Tokens.Del | undefined {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.inlineTokens(cap[2]),\n      };\n    }\n  }\n\n  autolink(src: string): Tokens.Link | undefined {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[1];\n        href = 'mailto:' + text;\n      } else {\n        text = cap[1];\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  url(src: string): Tokens.Link | undefined {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[0];\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n        } while (prevCapZero !== cap[0]);\n        text = cap[0];\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  inlineText(src: string): Tokens.Text | undefined {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      const escaped = this.state.inRawBlock;\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        escaped,\n      };\n    }\n  }\n}\n"],"names":["noopTest","edit","regex","opt","source","obj","name","val","valSource","other","bull","indent","newline","blockCode","fences","hr","heading","bullet","lheadingCore","lheading","lheadingGfm","_paragraph","blockText","_blockLabel","def","list","_tag","_comment","html","paragraph","blockquote","blockNormal","gfmTable","blockGfm","escape","inlineCode","br","inlineText","_punctuation","_punctuationOrSpace","_notPunctuationOrSpace","punctuation","_punctuationGfmStrongEm","_punctuationOrSpaceGfmStrongEm","_notPunctuationOrSpaceGfmStrongEm","blockSkip","emStrongLDelimCore","emStrongLDelim","emStrongLDelimGfm","emStrongRDelimAstCore","emStrongRDelimAst","emStrongRDelimAstGfm","emStrongRDelimUnd","anyPunctuation","autolink","_inlineComment","tag","_inlineLabel","link","reflink","nolink","reflinkSearch","inlineNormal","inlineGfm","inlineBreaks","block","inline","splitCells","tableRow","count","_a","row","match","offset","str","escaped","curr","cells","i","rtrim","c","invert","l","suffLen","findClosingBracket","b","level","outputLink","cap","raw","lexer","rules","href","title","text","token","indentCodeCompensation","matchIndentToCode","indentToCode","node","matchIndentInNode","indentInNode","Lexer","options","__publicField","src","next","tokens","lastParagraphClipped","lastToken","cutSrc","startIndex","tempSrc","tempStart","getStartIndex","_b","_c","maskedSrc","links","keepPrevChar","prevChar","extTokenizer","trimmed","lines","inBlockquote","currentLines","currentRaw","currentText","top","oldToken","newText","newToken","isordered","itemRegex","endsWithBlankLine","endEarly","itemContents","line","t","nextLine","blankLine","nextBulletRegex","hrRegex","fencesBeginRegex","headingBeginRegex","htmlBeginRegex","rawLine","nextLineWithoutTabs","istask","ischecked","lastItem","spacers","hasMultipleLineBreaks","headers","aligns","rows","item","align","cell","trimmedUrl","rtrimSlash","lastParenIndex","linkLen","linkString","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","lastCharLength","hasNonSpaceChars","hasSpaceCharsOnBothEnds","prevCapZero"],"mappings":"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"}